#ifndef READCON_H
#define READCON_H

#pragma once

/* Generated with cbindgen:0.29.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
namespace readcon {
#endif  // __cplusplus

/**
 * An iterator that lazily parses simulation frames from a `.con` or `.convel`
 * file's contents.
 *
 * This struct wraps an iterator over the lines of a string and, upon each iteration,
 * attempts to parse a complete `ConFrame`. Velocity sections are detected
 * automatically: if a blank line follows the coordinate blocks, the velocity
 * data is parsed into the atoms.
 *
 * The iterator yields items of type `Result<ConFrame, ParseError>`, allowing for
 * robust error handling for each frame.
 */
typedef struct ConFrameIterator ConFrameIterator;

typedef struct String String;

typedef struct CConFrameIterator {
    struct ConFrameIterator *iterator;
    struct String *file_contents;
} CConFrameIterator;

/**
 * An opaque handle to a full, lossless Rust `ConFrame` object.
 * The C/C++ side needs to treat this as a void pointer
 */
typedef struct RKRConFrame {
    uint8_t _private[0];
} RKRConFrame;

typedef struct CAtom {
    uint64_t atomic_number;
    double x;
    double y;
    double z;
    uint64_t atom_id;
    double mass;
    bool is_fixed;
    double vx;
    double vy;
    double vz;
    bool has_velocity;
} CAtom;

/**
 * A transparent, "lossy" C-struct containing only the core atomic data.
 * This can be extracted from an `RKRConFrame` handle for direct data access.
 * The caller is responsible for freeing the `atoms` array using `free_c_frame`.
 */
typedef struct CFrame {
    struct CAtom *atoms;
    uintptr_t num_atoms;
    double cell[3];
    double angles[3];
    bool has_velocities;
} CFrame;

/**
 * An opaque handle to a Rust `ConFrameWriter` object.
 * The C/C++ side needs to treat this as a void pointer
 */
typedef struct RKRConFrameWriter {
    uint8_t _private[0];
} RKRConFrameWriter;

/**
 * An opaque handle to a Rust `ConFrameBuilder` object.
 */
typedef struct RKRConFrameBuilder {
    uint8_t _private[0];
} RKRConFrameBuilder;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Creates a new iterator for a .con file.
 * The caller OWNS the returned pointer and MUST call `free_con_frame_iterator`.
 * Returns NULL if there are no more frames or on error.
 */
struct CConFrameIterator *read_con_file_iterator(const char *filename_c);

/**
 * Reads the next frame from the iterator, returning an opaque handle.
 * The caller OWNS the returned handle and must free it with `free_rkr_frame`.
 */
struct RKRConFrame *con_frame_iterator_next(struct CConFrameIterator *iterator);

/**
 * Frees the memory for an opaque `RKRConFrame` handle.
 */
void free_rkr_frame(struct RKRConFrame *frame_handle);

/**
 * Frees the memory for a `CConFrameIterator`.
 */
void free_con_frame_iterator(struct CConFrameIterator *iterator);

/**
 * Extracts the core atomic data into a transparent `CFrame` struct.
 * The caller OWNS the returned pointer and MUST call `free_c_frame` on it.
 */
struct CFrame *rkr_frame_to_c_frame(const struct RKRConFrame *frame_handle);

/**
 * Frees the memory of a `CFrame` struct, including its internal atoms array.
 */
void free_c_frame(struct CFrame *frame);

/**
 * Copies a header string line into a user-provided buffer.
 * This is a C style helper... where the user explicitly sets the buffer.
 * Returns the number of bytes written (excluding null terminator), or -1 on error.
 */
int32_t rkr_frame_get_header_line(const struct RKRConFrame *frame_handle,
                                  bool is_prebox,
                                  uintptr_t line_index,
                                  char *buffer,
                                  uintptr_t buffer_len);

/**
 * Gets a header string line as a newly allocated, null-terminated C string.
 *
 * The caller OWNS the returned pointer and MUST call `rkr_free_string` on it
 * to prevent a memory leak. Returns NULL on error or if the index is invalid.
 */
char *rkr_frame_get_header_line_cpp(const struct RKRConFrame *frame_handle,
                                    bool is_prebox,
                                    uintptr_t line_index);

/**
 * Frees a C string that was allocated by Rust (e.g., from `rkr_frame_get_header_line`).
 */
void rkr_free_string(char *s);

/**
 * Creates a new frame writer for the specified file.
 * The caller OWNS the returned pointer and MUST call `free_rkr_writer`.
 */
struct RKRConFrameWriter *create_writer_from_path_c(const char *filename_c);

/**
 * Frees the memory for an `RKRConFrameWriter`, closing the associated file.
 */
void free_rkr_writer(struct RKRConFrameWriter *writer_handle);

/**
 * Writes multiple frames from an array of handles to the file managed by the writer.
 */
int32_t rkr_writer_extend(struct RKRConFrameWriter *writer_handle,
                          const struct RKRConFrame *const *frame_handles,
                          uintptr_t num_frames);

/**
 * Creates a new frame writer with custom floating-point precision.
 * The caller OWNS the returned pointer and MUST call `free_rkr_writer`.
 */
struct RKRConFrameWriter *create_writer_from_path_with_precision_c(const char *filename_c,
                                                                   uint8_t precision);

/**
 * Creates a new frame builder with the given cell dimensions, angles, and header lines.
 * The caller OWNS the returned pointer and MUST call `free_rkr_frame_builder` or
 * `rkr_frame_builder_build`.
 * Returns NULL on error.
 */
struct RKRConFrameBuilder *rkr_frame_new(const double *cell,
                                         const double *angles,
                                         const char *prebox0,
                                         const char *prebox1,
                                         const char *postbox0,
                                         const char *postbox1);

/**
 * Adds an atom (without velocity) to the frame builder.
 * Returns 0 on success, -1 on error.
 */
int32_t rkr_frame_add_atom(struct RKRConFrameBuilder *builder_handle,
                           const char *symbol,
                           double x,
                           double y,
                           double z,
                           bool is_fixed,
                           uint64_t atom_id,
                           double mass);

/**
 * Adds an atom with velocity data to the frame builder.
 * Returns 0 on success, -1 on error.
 */
int32_t rkr_frame_add_atom_with_velocity(struct RKRConFrameBuilder *builder_handle,
                                         const char *symbol,
                                         double x,
                                         double y,
                                         double z,
                                         bool is_fixed,
                                         uint64_t atom_id,
                                         double mass,
                                         double vx,
                                         double vy,
                                         double vz);

/**
 * Consumes the builder and returns a finalized RKRConFrame handle.
 * The builder handle is invalidated after this call.
 * The caller OWNS the returned frame and MUST call `free_rkr_frame`.
 * Returns NULL on error.
 */
struct RKRConFrame *rkr_frame_builder_build(struct RKRConFrameBuilder *builder_handle);

/**
 * Frees a frame builder without building.
 */
void free_rkr_frame_builder(struct RKRConFrameBuilder *builder_handle);

/**
 * Reads the first frame from a .con file using mmap.
 * The caller OWNS the returned handle and MUST call `free_rkr_frame`.
 * Returns NULL on error.
 */
struct RKRConFrame *rkr_read_first_frame(const char *filename_c);

/**
 * Reads all frames from a .con file using mmap.
 * Returns an array of frame handles and sets `num_frames` to the count.
 * The caller OWNS both the array and each frame handle.
 * Free frames with `free_rkr_frame` and the array with `free_rkr_frame_array`.
 * Returns NULL on error.
 */
struct RKRConFrame **rkr_read_all_frames(const char *filename_c,
                                         uintptr_t *num_frames);

/**
 * Frees an array of frame handles returned by `rkr_read_all_frames`.
 * Each frame is freed individually, then the array itself.
 */
void free_rkr_frame_array(struct RKRConFrame **frames, uintptr_t num_frames);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace readcon
#endif  // __cplusplus

#endif  /* READCON_H */
