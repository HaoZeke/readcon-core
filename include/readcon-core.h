#ifndef READCON_H
#define READCON_H

#pragma once

/* Generated with cbindgen:0.29.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
namespace readcon {
#endif  // __cplusplus

typedef struct CAtom {
    uint64_t atomic_number;
    double x;
    double y;
    double z;
    uint64_t atom_id;
    double mass;
    bool is_fixed;
} CAtom;

typedef struct CFrame {
    const struct CAtom *atoms;
    uintptr_t num_atoms;
    double cell[3];
    double angles[3];
} CFrame;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Takes a C-style string symbol and returns the corresponding atomic number.
 * # Safety
 *
 */
uint64_t rust_symbol_to_atomic_number(const char *symbol_c);

/**
 * Parses a .con file and returns a pointer to a CFrame struct.
 *
 * The caller OWNS the returned pointer and MUST call free_con_frame()
 * on it to prevent a memory leak.
 * Returns a null pointer on error.
 * This function is `unsafe` because it dereferences a raw C pointer.
 * # Safety
 *
 */
struct CFrame *read_con_file(const char *filename_c);

/**
 * Frees the memory allocated by read_con_file.
 *
 * Must be called on any non-null pointer returned by read_con_file.
 * This function is `unsafe` because it deals with raw pointers and memory deallocation.
 * # Safety
 *
 */
void free_con_frame(struct CFrame *frame);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace readcon
#endif  // __cplusplus

#endif  /* READCON_H */
